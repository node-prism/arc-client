{
  "version": 3,
  "sources": ["../../../node_modules/.pnpm/@prsm+duplex@1.1.3/node_modules/@prsm/duplex/lib/client/commandclient.js", "../../../node_modules/.pnpm/@prsm+duplex@1.1.3/node_modules/@prsm/duplex/lib/common/codeerror.js", "../../../node_modules/.pnpm/@prsm+duplex@1.1.3/node_modules/@prsm/duplex/lib/common/command.js", "../../../node_modules/.pnpm/@prsm+duplex@1.1.3/node_modules/@prsm/duplex/lib/common/connection.js", "../../../node_modules/.pnpm/@prsm+duplex@1.1.3/node_modules/@prsm/duplex/lib/common/message.js", "../../../node_modules/.pnpm/@prsm+duplex@1.1.3/node_modules/@prsm/duplex/lib/common/errorserializer.js", "../../../node_modules/.pnpm/@prsm+duplex@1.1.3/node_modules/@prsm/duplex/lib/common/status.js", "../../../node_modules/.pnpm/@prsm+duplex@1.1.3/node_modules/@prsm/duplex/lib/server/ids.js", "../../../node_modules/.pnpm/@prsm+duplex@1.1.3/node_modules/@prsm/duplex/lib/client/queue.js", "../src/index.ts"],
  "sourcesContent": ["import { EventEmitter } from \"node:events\";\nimport net from \"node:net\";\nimport tls from \"node:tls\";\nimport { CodeError } from \"../common/codeerror\";\nimport { Command } from \"../common/command\";\nimport { Connection } from \"../common/connection\";\nimport { ErrorSerializer } from \"../common/errorserializer\";\nimport { Status } from \"../common/status\";\nimport { IdManager } from \"../server/ids\";\nimport { Queue } from \"./queue\";\nclass TokenClient extends EventEmitter {\n    options;\n    socket;\n    connection = null;\n    hadError;\n    status;\n    constructor(options) {\n        super();\n        this.options = options;\n        this.connect();\n    }\n    connect() {\n        if (this.status >= Status.CLOSED) {\n            return false;\n        }\n        this.hadError = false;\n        this.status = Status.CONNECTING;\n        if (this.options.secure) {\n            this.socket = tls.connect(this.options);\n        }\n        else {\n            this.socket = net.connect(this.options);\n        }\n        this.connection = null;\n        this.applyListeners();\n        return true;\n    }\n    close() {\n        if (this.status <= Status.CLOSED)\n            return false;\n        this.status = Status.CLOSED;\n        this.socket.end();\n        this.connection = null;\n        return true;\n    }\n    send(buffer) {\n        if (this.connection) {\n            return this.connection.send(buffer);\n        }\n        return false;\n    }\n    applyListeners() {\n        this.socket.on(\"error\", (error) => {\n            this.hadError = true;\n            this.emit(\"error\", error);\n        });\n        this.socket.on(\"close\", () => {\n            this.status = Status.OFFLINE;\n            this.emit(\"close\", this.hadError);\n        });\n        this.socket.on(\"secureConnect\", () => {\n            this.updateConnection();\n            this.status = Status.ONLINE;\n            this.emit(\"connect\");\n        });\n        this.socket.on(\"connect\", () => {\n            this.updateConnection();\n            this.status = Status.ONLINE;\n            this.emit(\"connect\");\n        });\n    }\n    updateConnection() {\n        const connection = new Connection(this.socket);\n        connection.on(\"token\", (token) => {\n            this.emit(\"token\", token, connection);\n        });\n        connection.on(\"remoteClose\", () => {\n            this.emit(\"remoteClose\", connection);\n        });\n        this.connection = connection;\n    }\n}\nclass QueueClient extends TokenClient {\n    queue = new Queue();\n    constructor(options) {\n        super(options);\n        this.applyEvents();\n    }\n    sendBuffer(buffer, expiresIn) {\n        const success = this.send(buffer);\n        if (!success) {\n            this.queue.add(buffer, expiresIn);\n        }\n    }\n    applyEvents() {\n        this.on(\"connect\", () => {\n            while (!this.queue.isEmpty) {\n                const item = this.queue.pop();\n                this.sendBuffer(item.value, item.expiresIn);\n            }\n        });\n    }\n}\nexport class CommandClient extends QueueClient {\n    ids = new IdManager(0xFFFF);\n    callbacks = {};\n    constructor(options) {\n        super(options);\n        this.init();\n    }\n    init() {\n        this.on(\"token\", (buffer) => {\n            try {\n                const data = Command.parse(buffer);\n                if (this.callbacks[data.id]) {\n                    if (data.command === 255) {\n                        const error = ErrorSerializer.deserialize(data.payload);\n                        this.callbacks[data.id](error, undefined);\n                    }\n                    else {\n                        this.callbacks[data.id](null, data.payload);\n                    }\n                }\n            }\n            catch (error) {\n                this.emit(\"error\", error);\n            }\n        });\n    }\n    async command(command, payload, expiresIn = 30_000, callback = undefined) {\n        if (command === 255) {\n            throw new CodeError(\"Command 255 is reserved.\", \"ERESERVED\", \"CommandError\");\n        }\n        const id = this.ids.reserve();\n        const buffer = Command.toBuffer({ id, command, payload });\n        this.sendBuffer(buffer, expiresIn);\n        // No 0, null or Infinity.\n        // Fallback to a reasonable default.\n        if (expiresIn === 0 || expiresIn === null || expiresIn === Infinity) {\n            expiresIn = 60_000;\n        }\n        const response = this.createResponsePromise(id);\n        const timeout = this.createTimeoutPromise(id, expiresIn);\n        if (typeof callback === \"function\") {\n            try {\n                const ret = await Promise.race([response, timeout]);\n                try {\n                    callback(ret, undefined);\n                }\n                catch (callbackError) { /* */ }\n            }\n            catch (error) {\n                callback(undefined, error);\n            }\n        }\n        else {\n            return Promise.race([response, timeout]);\n        }\n    }\n    createTimeoutPromise(id, expiresIn) {\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n                this.ids.release(id);\n                delete this.callbacks[id];\n                reject(new CodeError(\"Command timed out.\", \"ETIMEOUT\", \"CommandError\"));\n            }, expiresIn);\n        });\n    }\n    createResponsePromise(id) {\n        return new Promise((resolve, reject) => {\n            this.callbacks[id] = (error, result) => {\n                this.ids.release(id);\n                delete this.callbacks[id];\n                if (error) {\n                    reject(error);\n                }\n                else {\n                    resolve(result);\n                }\n            };\n        });\n    }\n}\n", "export class CodeError extends Error {\n    code;\n    name;\n    constructor(message, code, name) {\n        super(message);\n        if (typeof code === \"string\") {\n            this.code = code;\n        }\n        if (typeof name === \"string\") {\n            this.name = name;\n        }\n    }\n}\n", "export class Command {\n    static toBuffer({ payload, id, command }) {\n        if (payload === undefined)\n            throw new TypeError(\"The payload must not be undefined!\");\n        const payloadString = JSON.stringify(payload);\n        const buffer = Buffer.allocUnsafe(payloadString.length + 3);\n        buffer.writeUInt16LE(id, 0);\n        buffer.writeUInt8(command, 2);\n        buffer.write(payloadString, 3);\n        return buffer;\n    }\n    static parse(buffer) {\n        if (buffer.length < 3)\n            throw new TypeError(`Token too short! Expected at least 3 bytes, got ${buffer.length}!`);\n        const id = buffer.readUInt16LE(0);\n        const command = buffer.readUInt8(2);\n        const payload = JSON.parse(buffer.toString(\"utf8\", 3));\n        return { id, command, payload };\n    }\n}\n", "import { EventEmitter } from \"node:events\";\nimport { Message, NEWLINE } from \"./message\";\nconst CLOSE_TOKEN = Buffer.from(\"\\\\\\n\");\nexport class Connection extends EventEmitter {\n    duplex;\n    buffer = Buffer.allocUnsafe(0);\n    constructor(duplex) {\n        super();\n        this.duplex = duplex;\n        this.applyListeners();\n    }\n    applyListeners() {\n        this.duplex.on(\"data\", (buffer) => {\n            this.buffer = Buffer.concat([this.buffer, buffer]);\n            this.parse();\n        });\n        this.duplex.on(\"close\", () => this.emit(\"close\"));\n    }\n    parse() {\n        while (this.buffer.length > 0) {\n            const i = this.buffer.indexOf(NEWLINE);\n            if (i === -1)\n                break;\n            // +1 to include the separating newline.\n            const data = this.buffer.subarray(0, i + 1);\n            if (data.equals(CLOSE_TOKEN)) {\n                this.emit(\"remoteClose\");\n            }\n            else {\n                this.emit(\"token\", Message.unescape(data));\n            }\n            this.buffer = this.buffer.subarray(i + 1);\n        }\n    }\n    get isDead() {\n        return !this.duplex.writable || !this.duplex.readable;\n    }\n    send(buffer) {\n        if (this.isDead)\n            return false;\n        this.duplex.write(Message.escape(buffer));\n        return true;\n    }\n    close() {\n        if (this.isDead)\n            return false;\n        this.duplex.end();\n        return true;\n    }\n    remoteClose() {\n        if (this.isDead)\n            return false;\n        this.duplex.write(CLOSE_TOKEN);\n        return true;\n    }\n}\n", "export const NEWLINE = Buffer.from(\"\\n\")[0];\nconst ESC = Buffer.from(\"\\\\\")[0];\nconst ESC_N = Buffer.from(\"n\")[0];\nexport class Message {\n    // Escape all newlines and backslashes in a Buffer.\n    static escape(data) {\n        const result = [];\n        for (const char of data) {\n            switch (char) {\n                case ESC:\n                    // Escape the escaped backslash\n                    result.push(ESC);\n                    result.push(ESC);\n                    break;\n                case NEWLINE:\n                    // Escape newline\n                    result.push(ESC);\n                    result.push(ESC_N);\n                    break;\n                default:\n                    result.push(char);\n                    break;\n            }\n        }\n        result.push(NEWLINE);\n        return Buffer.from(result);\n    }\n    // Undoes what the escape method does.\n    static unescape(data) {\n        const result = [];\n        // Ignore last byte because it's the separating newline.\n        for (let i = 0; i < data.length - 1; i++) {\n            const char = data[i];\n            const next = data[i + 1];\n            if (char === ESC) {\n                switch (next) {\n                    case ESC:\n                        // Escaped escaped backslash.\n                        result.push(ESC);\n                        i += 1;\n                        break;\n                    case ESC_N:\n                        // Escaped newline.\n                        result.push(NEWLINE);\n                        i += 1;\n                        break;\n                    default:\n                        throw new Error(\"Unescaped backslash detected!\");\n                }\n            }\n            else {\n                result.push(char);\n            }\n        }\n        return Buffer.from(result);\n    }\n}\n", "export class ErrorSerializer {\n    // Converts an Error into a standard object.\n    static serialize(error) {\n        const data = {\n            message: error.message,\n            name: error.name,\n            stack: error.stack,\n        };\n        Object.assign(data, error);\n        return data;\n    }\n    // Converts an object into an Error instance.\n    static deserialize(data) {\n        const Factory = this.getFactory(data);\n        const error = new Factory(data.message);\n        Object.assign(error, data);\n        return error;\n    }\n    // Tries to find the global class for the error name and\n    // returns Error if none is found.\n    static getFactory(data) {\n        const name = data.name;\n        if (name.endsWith(\"Error\") && global[name]) {\n            return global[name];\n        }\n        return Error;\n    }\n}\n", "export var Status;\n(function (Status) {\n    Status[Status[\"ONLINE\"] = 3] = \"ONLINE\";\n    Status[Status[\"CONNECTING\"] = 2] = \"CONNECTING\";\n    Status[Status[\"CLOSED\"] = 1] = \"CLOSED\";\n    Status[Status[\"OFFLINE\"] = 0] = \"OFFLINE\";\n})(Status || (Status = {}));\n", "export class IdManager {\n    ids = [];\n    index = 0;\n    maxIndex;\n    constructor(maxIndex = 2 ** 16 - 1) {\n        this.maxIndex = maxIndex;\n    }\n    release(id) {\n        if (id < 0 || id > this.maxIndex) {\n            throw new TypeError(`ID must be between 0 and ${this.maxIndex}. Got ${id}.`);\n        }\n        this.ids[id] = false;\n    }\n    reserve() {\n        const startIndex = this.index;\n        while (true) {\n            const i = this.index;\n            if (!this.ids[i]) {\n                this.ids[i] = true;\n                return i;\n            }\n            if (this.index >= this.maxIndex) {\n                this.index = 0;\n            }\n            else {\n                this.index++;\n            }\n            if (this.index === startIndex) {\n                throw new Error(`All IDs are reserved. Make sure to release IDs when they are no longer used.`);\n            }\n        }\n    }\n}\n", "export class QueueItem {\n    value;\n    expiration;\n    constructor(value, expiresIn) {\n        this.value = value;\n        this.expiration = Date.now() + expiresIn;\n    }\n    get expiresIn() {\n        return this.expiration - Date.now();\n    }\n    get isExpired() {\n        return Date.now() > this.expiration;\n    }\n}\nexport class Queue {\n    items = [];\n    add(item, expiresIn) {\n        this.items.push(new QueueItem(item, expiresIn));\n    }\n    get isEmpty() {\n        let i = this.items.length;\n        while (i--) {\n            if (this.items[i].isExpired) {\n                this.items.splice(i, 1);\n            }\n            else {\n                return false;\n            }\n        }\n        return true;\n    }\n    pop() {\n        while (this.items.length) {\n            const item = this.items.shift();\n            if (!item.isExpired) {\n                return item;\n            }\n        }\n        return null;\n    }\n}\n", "import { CommandClient } from \"@prsm/duplex\";\n\nexport type QueryPayload = {\n  collection: string;\n  operation: \"find\" | \"insert\" | \"update\" | \"remove\" | \"drop\";\n  data?: {\n    query?: object;\n    operations?: object;\n    options?: object;\n  };\n  accessToken?: string;\n};\n\ntype AuthPayload = {\n  username: string;\n  password: string;\n};\n\ntype RefreshPayload = {\n  accessToken: string;\n  refreshToken: string;\n};\n\nexport class ArcClient {\n  public readonly client: CommandClient;\n  private authenticated = false;\n  private username: string;\n  private password: string;\n  private tokens: { accessToken: string; refreshToken: string };\n\n  constructor({ host, port, secure, username, password }) {\n    this.client = new CommandClient({ host, port, secure });\n    this.username = username;\n    this.password = password;\n  }\n\n  async refresh() {\n    const { accessToken, refreshToken } = this.tokens;\n    const result: { error?: string, accessToken?: string, refreshToken?: string } = await this.client.command(1, { accessToken, refreshToken });\n\n    if (result.error) {\n      throw new Error(\"Failed to refresh tokens\");\n    }\n\n    this.tokens = {\n      accessToken: result.accessToken,\n      refreshToken: result.refreshToken\n    };\n  }\n\n  async auth() {\n    const payload = {\n      username: this.username,\n      password: this.password\n    };\n\n    const result: { error?: string, accessToken?: string, refreshToken?: string } = await this.client.command(0, payload);\n\n    if (result.error) {\n      throw new Error(\"Failed to authenticate\");\n    }\n\n    this.tokens = {\n      accessToken: result.accessToken,\n      refreshToken: result.refreshToken\n    };\n\n    this.authenticated = true;\n  }\n\n  async query(query: QueryPayload) {\n    if (!this.authenticated) {\n      try {\n        await this.auth();\n      } catch (e) {\n        throw new Error(\"Failed to authenticate\");\n      }\n    }\n\n    query.accessToken = this.tokens.accessToken;\n\n    let result;\n\n    result = await this.client.command(2, query);\n\n    if (result.error) {\n      try {\n        await this.refresh();\n      } catch (e) {\n        throw new Error(\"Failed to refresh tokens\");\n      }\n\n      return await this.query(query);\n    }\n\n    return result;\n  }\n}\n\nasync function main() {\n  const arc = new ArcClient({\n    host: \"localhost\",\n    port: 3351,\n    secure: false,\n    username: \"root\",\n    password: \"root\"\n  });\n\n  let result = await arc.query({ collection: \"planets\", operation: \"drop\" });\n  console.log(\"Drop result\", result);\n  result = await arc.query({\n    collection: \"planets\",\n    operation: \"insert\",\n    data: {\n      query: [{ name: \"Mercury\" }, { name: \"Venus\" }, { name: \"Earth\" }, { name: \"Mars\" }],\n    },\n  });\n  console.log(\"Insert result\", result);\n  result = await arc.query({\n    collection: \"planets\",\n    operation: \"find\",\n    data: {\n      query: { name: { $includes: \"M\" } },\n    },\n  });\n  console.log(\"Find result\", result);\n}\n\nmain();\n"],
  "mappings": "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",
  "names": ["EventEmitter", "net", "tls", "CodeError", "message", "code", "name", "Command", "payload", "id", "command", "payloadString", "buffer", "EventEmitter", "NEWLINE", "ESC", "ESC_N", "Message", "data", "result", "char", "i", "next", "CLOSE_TOKEN", "Connection", "EventEmitter", "duplex", "buffer", "i", "NEWLINE", "data", "Message", "ErrorSerializer", "error", "data", "Factory", "name", "Status", "IdManager", "maxIndex", "id", "startIndex", "i", "QueueItem", "value", "expiresIn", "Queue", "item", "i", "TokenClient", "EventEmitter", "options", "Status", "tls", "net", "buffer", "error", "connection", "Connection", "token", "QueueClient", "Queue", "expiresIn", "item", "CommandClient", "IdManager", "data", "Command", "ErrorSerializer", "command", "payload", "callback", "CodeError", "id", "response", "timeout", "ret", "resolve", "reject", "result", "ArcClient", "host", "port", "secure", "username", "password", "CommandClient", "accessToken", "refreshToken", "result", "payload", "query", "main", "arc"]
}
